(multi-if (= 1 2) "good" "bad")
(defmacro multi-if [test then else] (list 'test (list 'hash-map :true then, :false else)))
(macroexpand '(multi-if (= 1 2) "then" "else"))
(multi-if (= 1 2) "good" "bad")
(multi-if :true "good" "bad")
(multi-if :true "then" "else")
(defmacro multi-if [test then else] (list 'test (list 'hash-map :true (list 'then), :false (list 'else))))
(macroexpand '(multi-if (= 1 2) "then" "else"))
(multi-if :true "then" "else")
(multi-if :true "zebra" "else")
(defmacro multi-if [test then else] (list ':true (list 'hash-map :true (list 'then), :false (list 'else))))
(multi-if :true "zebra" "else")
(defmacro multi-if [test then else] (list ':true (list 'hash-map :true then, :false else)))
(multi-if :true "zebra" "else")
(defmacro multi-if [test then else] (list ':true (list 'hash-map :true then :false else)))
(multi-if :true "zebra" "else")
(defmacro multi-if [test then else] (list 'test (list 'hash-map :true then :false else)))
(multi-if :true "zebra" "else")
(macroexpand '(multi-if :true "then" "else"))
(macroexpand '(multi-if :true "zebra" "buffalo"))
(macroexpand '(multi-if "i am test" "zebra" "buffalo"))
(defmacro multi-if [pigeon then else] (list 'pigeon (list 'hash-map :true then :false else)))
(macroexpand '(multi-if "i am test" "zebra" "buffalo"))
(defmacro multi-if [pigeon then else] (list 'str pigeon) (list 'hash-map :true then :false else)))
(defmacro multi-if [pigeon then else] (list 'str pigeon) (list 'hash-map :true then :false else))))
(defmacro multi-if [pigeon then else] (list 'str pigeon) (list 'hash-map :true then :false else))
(macroexpand '(multi-if "i am test" "zebra" "buffalo"))
(defmacro multi-if [pigeon then else] (list '(list 'keyword (list 'str pigeon)) (list 'hash-map :true then :false else)))
(macroexpand '(multi-if "i am test" "zebra" "buffalo"))
(defmacro multi-if [pigeon then else] (list (list 'keyword (list 'str pigeon)) (list 'hash-map :true then :false else)))
(macroexpand '(multi-if "i am test" "zebra" "buffalo"))
(defmacro multi-if [pigeon then else] (list (list 'keyword (list 'str pigeon) (list 'hash-map :true then :false else))))
(macroexpand '(multi-if "i am test" "zebra" "buffalo"))
(defmacro multi-if [pigeon then else] (list (list 'keyword (list 'str pigeon)) (list 'hash-map :true then :false else)))
(macroexpand '(multi-if "i am test" "zebra" "buffalo"))
(multi-if (= 1 2) "zebra" "buffalo")
(multi-if (= 1 1) "zebra" "buffalo")
exit
(defmacro multi-if [pigeon & more] (list (list 'keyword (list 'str pigeon)) (list 'hash-map :true (:then more) :false (:else more)))
)
(macroexpand '(multi-if "i am test" "zebra" "buffalo"))
(defmacro multi-if [pigeon & more] (list (list 'keyword (list 'str pigeon)) (list 'hash-map :true (list ':then more) :false (list ':else more)))
)
(macroexpand '(multi-if "i am test" "zebra" "buffalo"))
(macroexpand '(multi-if "i am test" :then 'zebra :else 'buffalo))
(macroexpand '(multi-if "i am test" :then "zebra" :else "buffalo"))
:then "zebra :else "buffalo"
)
(:then "zebra :else "buffalo")
(hashmap :then "zebra :else "buffalo")
)
(hashmap :then "zebra" :else "buffalo")
(hash-map :then "zebra" :else "buffalo")
(defmacro multi-if [pigeon & more] (list (list 'keyword (list 'str pigeon)) (list 'hash-map :true (list ':then (list 'hash-map more) :false (list ':else (list 'hash-map more)))
)
(macroexpand '(multi-if "i am test" :then "zebra" :else "buffalo"))
(multi-if (= 1 1) "zebra" "buffalo")
(multi-if (= 1 1) :then "zebra" :else "buffalo")
exit
(defmacro assert-equals [actual expected actual2 expected2]
  (list 'and (list '= expected actual)) (list '= expected2 actual2))
(assert-equals 3 1 2 2)
(macro-expand '(assert-equals 3 1 2 2))
(macroexpand '(assert-equals 3 1 2 2))
  (list 'and (list '= expected actual) (list '= expected2 actual2)))
  (list 'and (list '= expected actual) (list '= expected2 actual2))
(defmacro assert-equals [actual expected actual2 expected2]
  (list 'and (list '= expected actual) (list '= expected2 actual2))
)
(macroexpand '(assert-equals 3 1 2 2))
(assert-equals 3 1 2 2)
exut
exit
(:then then :else else)
'(:then then :else else)
(:then '(:then then :else else))
(hash-map '(:then then :else else))
(hash-map (:then then :else else))
(hash-map :then then :else else)
(hash-map :then "then" :else "else")
(hash-map (:then "then" :else "else"))
(:bear (hash-map :then "then" :else "else"))
(hash-map '(:then "then" :else "else"))
(list 1 2 3)
(vector 1 2 3)
  (list 'and (list '= ~expected ~actual) (list '= ~expected2 ~actual2))
(hash-map '(:then then :else else))
(zipmap (:them "then" :else "else"))
(zipmap (:then "then" :else "else"))
(apply hash-map (:then "then" :else "else"))
(apply hash-map (:then "then" :else "else")
)
(apply map (:then "then" :else "else"))
(apply map list (:then "then" :else "else"))
(apply map list '(:then "then" :else "else"))
(apply map '(:then "then" :else "else"))
(apply hash-map '(:then "then" :else "else"))
(:then (apply hash-map '(:then "then" :else "else")))
(apply hash-map (:then "then" :else "else"))
(type (:then "then"))
(type '(:then "then"))
(defn test [& args] (apply hash-map args))
(user/test (:then "then" :else "else"))
(user/test '(:then "then" :else "else"))
(user/test :then "then" :else "else")
(rename-keys {:a 1} {:a :new-a}
)
(rename {:a 1} {:a :new-a})
(clojure.set.rename-keys {:a 1} {:a :new-a}
)
(require 'clojure.set)
(rename-keys {:a 1} {:a :new-a})
(rename {:a 1} {:a :new-a})
(clojure.set/rename-keys {:a 1} {:a :new-a})
(defmacro build-map [map-data]
  (println map-data)
  (list 'apply hash-map map-data))
(defmacro build-true-false-map [then-else]
  (println then-else)
  (list 'clojure.set/rename-keys (list 'build-map then-else) {:then :true :else :false}))
(defmacro then [& then-else]
  (println then-else)
  (list ':true (list 'build-true-false-map then-else)))
(macroexpand (then :then (println "ok") :else (println "bad")))
(macroexpand (then :then "ok" :else "bad"))
(defmacro build-map [map-data]
  (list 'apply hash-map map-data))
(defmacro build-true-false-map [then-else]
  (list 'clojure.set/rename-keys (list 'build-map then-else) {:then :true :else :false}))
(defmacro then [& then-else]
  (list ':true (list 'build-true-false-map then-else)))
(then :then "ok" :else "bad")
(macroexpand (then :then "ok" :else "bad"))
(then :bhen "ok" :else "bad")
(defmacro build-map [map-data]
  (println map-data)
  (list 'apply hash-map map-data))
(defmacro build-true-false-map [then-else]
  (println then-else)
  (list 'clojure.set/rename-keys (list 'build-map then-else) {:then :true :else :false}))
(defmacro then [& then-else]
  (println then-else)
  (list ':true (list 'build-true-false-map then-else)))
(macroexpand (then :then "ok" :else "bad"))
(defmacro build-map [map-data]
  (println map-data)
  (list 'apply hash-map map-data))
(defmacro build-true-false-map [then-else]
  (println then-else)
  (list 'clojure.set/rename-keys (list 'build-map then-else) {:then :true :else :false})
  (println "done"))
(defmacro then [& then-else]
  (println then-else)
  (list ':true (list 'build-true-false-map then-else)))
(then :then "ok" :else "bad")
(defmacro build-map [map-data]
  (println map-data)
  (list 'apply hash-map map-data))
(defmacro build-true-false-map [then-else]
  (println then-else)
  (list 'clojure.set/rename-keys (list 'build-map then-else) {:then :true :else :false})
  (println (list 'clojure.set/rename-keys (list 'build-map then-else) {:then :true :else :false})))
(defmacro then [& then-else]
  (println then-else)
  (list ':true (list 'build-true-false-map then-else)))
(then :then "ok" :else "bad")
(defmacro build-map [map-data]
  (println map-data)
  (list 'apply hash-map map-data))
(defmacro build-true-false-map [then-else]
  (println then-else)
  (list 'clojure.set/rename-keys (list 'build-map then-else) {:then :true :else :false}))
(defmacro then [& then-else]
  (list ':true
    (list 'build-true-false-map then-else)
    (println "done")
    (list 'build-true-false-map then-else)
  )
)
(it "returns the consequent"
    (should= nil (then :then "ok" :else "bad")))
(then :then "ok" :else "bad")
(defmacro build-true-false-map [then-else]
  (list 'clojure.set/rename-keys (list 'build-map then-else) {:then :true :else :false}))
(macroexpand (build-true-false-map '(:then (println "ok") :else (println "bad"))))
(macroexpand (build-true-false-map (:then (println "ok") :else (println "bad"))))
(defmacro then [& then-else-data]
  (list ':true
    (list 'build-true-false-map ~then-else-data)
  )
)
(macroexpand (build-true-false-map (:then (println "ok") :else (println "bad"))))
(defmacro build-map [map-data]
  (list 'apply hash-map map-data))
(defmacro build-true-false-map [then-else]
  (println then-else)
  (list 'clojure.set/rename-keys (list 'build-map then-else) {:then :true :else :false}))
(defmacro then [& then-else-data]
  (list ':true
    (list 'build-true-false-map ~then-else-data)
  )
)
(macroexpand (then :then "ok" :else "bad"))
(load-file multiif.clj)
exit
(load-file src/multiif.clj)
(load-file ./src/multiif.clj)
exit
(load-file "multiif.clj")
(load-file "./multiif.clj")
(load-file "multiif.clj")
(load-file "/src/multiif.clj")
exit
(load-file "src/multiif.clj")
(macroexpand (evaluate (> 1 3)))
(macroexpand (multiif/evaluate (> 1 3)))
(macroexpand-1 (multiif/evaluate (> 1 3)))
(macroexpand-1 '(multiif/evaluate (> 1 3)))
(clojure.core/keyword (clojure.core/str (> 1 3)))
(clojure.set/rename-keys (multiif/build-map (:then ok :else bad)) {:then :true, :else :false})
(clojure.set/rename-keys (multiif/build-map (:then "ok" :else "bad")) {:then :true, :else :false})
(multiif/build-map (:then "ok" :else "bad"))
(apply hash-map (:then "ok" :else "bad"))
(apply hash-map '(:then "ok" :else "bad"))
(multiif/build-map '(:then "ok" :else "bad"))
"ok"
(load "src/multiif.clj")
exit
(load-file "src/multiif.clj")
(multiif/build-map '(:then "ok" :else "bad"))
(multi-if (> 1 3) :then "ok" :else "bad")
(multiif/multi-if (> 1 3) :then "ok" :else "bad")
(macroexpand-1 '(multiif/build-true-false-map (:then "ok" :else "bad")))
(clojure.set/rename-keys (multiif/build-map (:then "ok" :else "bad")) {:then :true, :else :false})
(multiif/build-map (:then "ok" :else "bad"))
(multiif/build-map '(:then "ok" :else "bad"))
(macroexpand-1 '(multiif/build-true-false-map :then "ok" :else "bad"))
(macroexpand-1 '(multiif/build-true-false-map (:then "ok" :else "bad")))
(list (:then "then" :else "else"))
(apply hash-map (:then "then" :else "else"))
(apply hash-map (list (:then "then" :else "else")))
(apply hash-map (seq (:then "then" :else "else")))
(apply hash-map (lazy-seq (:then "then" :else "else")))
(defn log
  [message & args]
  (println "args: " args))
(log "message from " "192.0.0.76" "service:xyz")
(defn log
  [message & args]
  (println "args: " (type args)))
(log "message from " "192.0.0.76" "service:xyz")
(defn log
  [message & args]
  (println "args: " (apply hash-map args)))
(log "message from " "192.0.0.76" "service:xyz")
(+ 1 2)
(defn sum [ x y ]
(+ x y)
)
(sum 3 2)
(defn assert-equals [ x y ]
(= x y)
)
(assert-equals 5 5)
(assert-equals (inc 4) 5)
(assert-equals (inc 5) 5)
'(1 2 3)
'(+ 1 2)
(+ 1 2)
(apply hash-map '(:then "ok" :else "bad))
)
exit
EXIT!
(apply hash-map '(:then "ok" :else "bad))
"
(apply hash-map '(:then "ok" :else "bad"))
(:then (apply hash-map '(:then "ok" :else "bad")))
(:true (apply hash-map '(:true "ok" :false "bad")))
(:false (apply hash-map '(:true "ok" :false "bad")))
((< 1 3) (apply hash-map '(:true "ok" :false "bad")))
((keyword (str (< 1 3))) (apply hash-map '(:true "ok" :false "bad")))
(load-file "src/multiif.clj")
(multiif/build-true-false-map '(:then "then" :else "else"))
(multiif/build-true-false-map (:then "then" :else "else"))
(multiif/build-true-false-map '(:then "then" :else "else"))
(load-file "src/multiif.clj")
(# 1)
(load-file "src/multiif.clj")
#(+ 1 1)
(#(+ 1 1))
((+ 1 1))
(+ 1 1)
(#'(+ 1 1))
(load-file "src/multiif.clj")
(1)
(+ 1 1)
(type (+ 1 1)
)
(type (+ 1 1))
'(1)
(type '(1))
(into [] '(+ 1 1))
(into () '(+ 1 1))
(into #() '(+ 1 1))
(into # '(+ 1 1))
(into #() '(+ 1 1))
(into {} '(+ 1 1))
(into {} '(1 1))
(into {} '(:one 1))
(into {} '(:one "1"))
(first '((+ 1 1))
)
(first '(+ 1 1))
)
(first '((+ 1 1)))
(first [(+ 1 1)])
[:then "then" :else "else"]
(hash-map [:then "then" :else "else"])
(apply hash-map [:then "then" :else "else"])
(load-file "src/multiif.clj")
(sum-all :hi (+ 1 1) :bye "service:xyz")
(require "src/multiif.clj")
(sum-all :hi (+ 1 1) :bye "service:xyz")
(multiif/sum-all :hi (+ 1 1) :bye "service:xyz")
(:hi (multiif/sum-all :hi (+ 1 1) :bye "service:xyz"))
(load-file "src/multiif.clj")
'(+ 1 2)
('(+ 1 2))
(eval '(+ 1 2))
(load-file "src/multiif.clj")
(require "src/multiif.clj")
(:hi (multiif/sum-all :hi (+ 1 1) :bye "service:xyz"))
(:hi (multiif/multi-if :hi :then (+ 1 1) :else (+ 2 2) ))
(multiif/multi-if :hi :then (+ 1 1) :else (+ 2 2) )
(require "src/multiif.clj")
(multi-if :hi :then (+ 1 1) :else (+ 2 2) )
(multiif/multi-if :hi :then (+ 1 1) :else (+ 2 2) )
(multiif/evaluate (+ 1 1))
(require "src/multiif.clj")
(load-file "src/multiif.clj")
(multiif/evaluate (+ 1 1))
(load-file "src/multiif.clj")
exit
(load-file "src/multiif.clj")
(multiif/multi-if :hi :then (+ 1 1) :else (+ 2 2) )
(require "src/multiif.clj")
(load-file "src/multiif.clj")
(multiif/multi-if :hi :then (+ 1 1) :else (+ 2 2) )
(load-file "src/multiif.clj")
(multiif/multi-if :hi :then (+ 1 1) :else (+ 2 2) )
(multiif/multi-if (= 1 1) :then (+ 1 1) :else (+ 2 2) )
(multiif/multi-if :true :then (+ 1 1) :else (+ 2 2) )
(load-file "src/multiif.clj")
(multiif/multi-if :true :then (+ 1 1) :else (+ 2 2) )
(load-file "src/multiif.clj")
(multiif/multi-if :true :then (+ 1 1) :else (+ 2 2) )
(load-file "src/multiif.clj")
(multiif/multi-if :true :then (+ 1 1) :else (+ 2 2) )
(load-file "src/multiif.clj")
(multiif/multi-if :true :then (+ 1 1) :else (+ 2 2) )
(load-file "src/multiif.clj")
(multiif/multi-if :true :then (+ 1 1) :else (+ 2 2) )
(load-file "src/multiif.clj")
(multiif/multi-if :true :then (+ 1 1) :else (+ 2 2) )
(load-file "src/multiif.clj")
(clojure.core/apply clojure.core/hash-map (:then (println ok) :else (println bad)
))
(clojure.core/apply clojure.core/hash-map '(:then (println ok) :else (println bad)))
(load-file "src/multiif.clj")
(clojure.set/rename-keys (multiif/build-map (quote (:then (println ok) :else (println bad)))) {:then :true, :else :false})
(load-file "src/multiif.clj")
(multiif/multi-if :true :then (+ 1 1) :else (+ 2 2) )
(multiif/multi-if (= 1 1) :then (+ 1 1) :else (+ 2 2) )
(load-file "src/multiif.clj")
exit!
exi
exit
(eval '(+ 1 1)
)
(eval '(+ 1 1))
(eval '1)
exit
(load-file "src/multiif.clj")
exit
(load-file "src/multiif.clj")
(+ "conse" "quent")
(cons "conse" "quent")
(conj "conse" "quent")
(concat "conse" "quent")
(clojure.string/join "consequen" "t")
(')
'
'()
(if (< number 100) "yes" "no")
(if (< 99 100) "yes" "no")
(split '(:then :else))
(hash-map '(:then :else))
(hash-map '(:then "then" :else "else"))
(apply hash-map '(:then "then" :else "else"))
(apply hash-map '(:then :else))
(:then (apply hash-map '(:then :else)))
(defn index-of [e coll] (first (keep-indexed #(if (= e %2) %1) coll)))
a = '(:this "this")
(defn index-of [:else a] (first (keep-indexed #(if (= e %2) %1) coll)))
(defn index-of [":else" a] (first (keep-indexed #(if (= e %2) %1) coll)))
(defn index-of [:this a] (first (keep-indexed #(if (= e %2) %1) coll)))
(defn index-of [:this '(:this "ok")] (first (keep-indexed #(if (= e %2) %1) coll)))
(index-of :this '(:this "ok"))
(index-of "ok" '(:this "ok"))
(index-of :else '(:this "ok"))
(not= (inc 4) (and 4 5))
(not= (inc 4) (and 4 6))
(not= (inc 4) (and 5 6))
(not= (inc 4) (or 5 6))
(not= (inc 4) (or 6 5))
(not= (inc 4) (and 6 5))
(not= (inc 4) (and 5 6))
(inc 4)
(= (inc 4) (or 5 6))
(= (inc 4) (or 6 5))
(or (= (inc 4) 5) (= (inc 4) 6))
(or (= (inc 4) 6) (= (inc 4) 5))
'1
(+ 1)
(+ 1 1)
'(+ 1 1)
':true
'(:true)
'(:true 1)
(hash-set {:key "value"} {:b-key "b-value"})
(mapcat {:key "value"} {:b-key "b-value"})
(join {:key "value"} {:b-key "b-value"})
(hash-map {:key "value"} {:b-key "b-value"})
(merge-with {:key "value"} {:b-key "b-value"})
(merge-with yield {:key "value"} {:b-key "b-value"})
(merge {:key "value"} {:b-key "b-value"})
{:true "ok"}
(quote (:then 1 :else 2))
(defn index-of [e coll]
  (first
    (keep-indexed #(if (= e %2) %1) coll)))
(index-of :this (quote (:then 1 :else 2)))
(index-of :this '(:then 1 :else 2))
(index-of :then '(:then 1 :else 2))
(index-of :then (quote (:then 1 :else 2)))
(defn does-key-exist-in [key coll]
  (println coll)
  (not= nil (index-of key coll)))
(does-key-exist-in :this '(:then 1 :else 2))
(defn does-key-exist-in [key coll]
  (println key)
  (println coll)
  (not= nil (index-of key coll)))
(does-key-exist-in :this '(:then 1 :else 2))
(does-key-exist-in :then '(:then 1 :else 2))
'1 2 3
'(1 2 3)
(nth '(1 2 3 4) 1)
(nth '(1 2 3 4) 5)
(nth '(1 2 3 4) nil)
(nth '(1 2 3 4) 100)
(nth '(1 2 3 4) "not found")
(nth '(1 2 3 4) 5 "not found")
(nth '(1 2 3 4) 5 1)
(nth '(1 2 3 4) 5 nil)
(not-any? (= 1) '(1 2 3))
(not-any? (1) '(1 2 3))
(not-any? 1 '(1 2 3))
(not-any? 1 [1 2 3])
(not-any? (+ 1 1) [1 2 3])
(not-any? (+ % 1) [1 2 3])
(not-any? (+ %1 1) [1 2 3])
(not-any? (+ 1 %) [1 2 3])
(not-any? (+ 1 %1) [1 2 3])
(not-any? 1 [1 2 3])
(not-any? #(= 1 %) [1 2 3])
(load-file "src/multiif.clj")
(multi-if (> 3 1))
(multiif/multi-if (> 3 1))
(multifi/multi-if (> 3 1) :then 'ok)
(multiif/multi-if (> 3 1) :then 'ok)
(multiif/multi-if (< 5 3) :else 'ok)
(multiif/multi-if (> 3 1) :else 'oops)
(multiif/multi-if (> 3 1) :then)
(multiif/multi-if (> 3 1) :else 'oops :then 'ok)
(multiif/multi-if (> 3 1) :else 'oops :then (println 'hi)
'ok)
(multi-if (> 3 9) :then (println
'launching-missiles) :else 'ok)
(multiif/multi-if (> 3 9) :then (println
'launching-missiles) :else 'ok)
(multi-if (> 3 1) :else 'oops :then (println 'hi)
)
(multiif/multi-if (> 3 1) :else 'oops :then (println 'hi))
(multiif/multi-if (> 3 1) :else 'oops :then (println 'hi) 'ok)
('ok)
'ok
(println 'hi) 'ok
((println 'hi) 'ok)
exit
